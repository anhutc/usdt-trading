<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Scanner Pro - Phi√™n b·∫£n Portable</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
            user-select: none;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        .filter-panel {
            width: 400px;
            background: #2d2d2d;
            padding: 20px;
            border-right: 1px solid #404040;
            overflow-y: auto;
        }

        .filter-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #ffd700;
            text-align: center;
        }

        .exchange-section {
            margin-bottom: 25px;
        }

        .exchange-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #3a3a3a;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .exchange-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
            cursor: pointer;
        }

        .exchange-name {
            flex: 1;
            cursor: pointer;
        }

        .exchange-dropdown {
            background: #4a4a4a;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            border-radius: 3px;
            cursor: pointer;
        }

        .exclusion-section {
            margin-bottom: 25px;
        }

        .exclusion-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .exclusion-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
            cursor: pointer;
        }

        .candle-section {
            margin-bottom: 25px;
        }

        .candle-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffd700;
        }

        .condition-radio-group {
            margin-bottom: 15px;
            padding: 15px;
            background: #3a3a3a;
            border-radius: 5px;
            border: 1px solid #555;
        }

        .radio-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .radio-item:last-child {
            margin-bottom: 0;
        }

        .radio-input {
            margin-right: 10px;
            transform: scale(1.2);
            cursor: pointer;
        }

        .radio-label {
            cursor: pointer;
            line-height: 1.4;
        }

        .radio-description {
            font-size: 12px;
            color: #cccccc;
            margin-left: 25px;
            margin-top: 2px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            display: block;
            margin-bottom: 5px;
            color: #cccccc;
        }

        .input-field {
            width: 100%;
            padding: 8px;
            background: #4a4a4a;
            border: 1px solid #555;
            border-radius: 3px;
            color: white;
            cursor: text;
        }

        .input-field:focus {
            outline: none;
            border-color: #ffd700;
        }

        .volume-section {
            margin-bottom: 30px;
        }

        .scan-button {
            width: 100%;
            padding: 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .scan-button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .scan-button:active {
            transform: translateY(0);
        }

        .results-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            background: #2d2d2d;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #404040;
        }

        .results-table th {
            background: #404040;
            color: #ffd700;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .results-table tr {
            cursor: pointer;
            transition: all 0.2s;
        }

        .results-table tr:hover {
            background: #3a3a3a;
            transform: scale(1.01);
        }

        .results-table tr.selected {
            background: #4a4a4a;
            border-left: 4px solid #ffd700;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #ffd700;
        }

        .loading h2 {
            margin-bottom: 20px;
            font-size: 28px;
        }

        .loading p {
            font-size: 16px;
            color: #cccccc;
        }

        /* Progress Bar Styles */
        .progress-container {
            margin: 30px 0;
            background: #3a3a3a;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #555;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .progress-title {
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
        }

        .progress-status {
            font-size: 14px;
            color: #cccccc;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #2d2d2d;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        .progress-details {
            margin-top: 15px;
            font-size: 14px;
            color: #cccccc;
            text-align: left;
        }

        .progress-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #404040;
        }

        .progress-item:last-child {
            border-bottom: none;
        }

        .progress-item-name {
            color: #ffffff;
        }

        .progress-item-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-pending {
            background: #ff9800;
            color: white;
        }

        .status-processing {
            background: #2196F3;
            color: white;
        }

        .status-success {
            background: #4CAF50;
            color: white;
        }

        .status-error {
            background: #f44336;
            color: white;
        }

        .hidden {
            display: none;
        }

        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #333;
            color: #ffd700;
            padding: 10px;
            text-align: center;
            font-size: 12px;
            border-top: 1px solid #555;
        }

        .success-message {
            background: #4CAF50;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .exchange-item.selected {
            background: #4a4a4a;
            border: 1px solid #ffd700;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Chart Modal Styles */
        .chart-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .chart-modal.show {
            display: flex;
        }

        .chart-container {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            position: relative;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #555;
        }

        .chart-title {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
        }

        .close-chart {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .close-chart:hover {
            background: #d32f2f;
        }

        .chart-info {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #3a3a3a;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
        }

        .chart-info span {
            color: #ffd700;
        }

        .candlestick-chart {
            width: 100%;
            height: 400px;
            background: white;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        .volume-chart {
            width: 100%;
            height: 150px;
            background: #f5f5f5;
            border-radius: 5px;
            margin-top: 20px;
            position: relative;
        }

        .chart-legend {
            margin-top: 20px;
            text-align: center;
            color: #cccccc;
        }

        .legend-item {
            display: inline-block;
            margin: 0 15px;
        }

        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 3px;
        }

        .legend-green {
            background: #4CAF50;
        }

        .legend-red {
            background: #f44336;
        }

        .legend-highlight {
            background: #ffd700;
        }

        .candle-details {
            margin-top: 20px;
            padding: 15px;
            background: #3a3a3a;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }

        .candle-details h4 {
            color: #ffd700;
            margin-bottom: 15px;
            text-align: center;
        }

        .candle-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .candle-table th,
        .candle-table td {
            padding: 8px;
            text-align: center;
            border: 1px solid #555;
        }

        .candle-table th {
            background: #404040;
            color: #ffd700;
            font-weight: bold;
        }

        .candle-table tr:nth-child(even) {
            background: #2d2d2d;
        }

        .candle-table tr:hover {
            background: #4a4a4a;
        }

        .candle-table .highlighted {
            background: #2d5a2d !important;
            border: 2px solid #ffd700;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="filter-panel" id="filterPanel">
            <div class="filter-title">B·ªô L·ªçc</div>
            
            <div class="exchange-section">
                <div class="exchange-item" id="binance-item">
                    <input type="checkbox" class="exchange-checkbox" id="binance">
                    <span class="exchange-name">Binance</span>
                    <select class="exchange-dropdown">
                        <option>C·∫∑p USDT</option>
                        <option>C·∫∑p BTC</option>
                        <option>C·∫∑p ETH</option>
                    </select>
                </div>
                <div class="exchange-item" id="okx-item">
                    <input type="checkbox" class="exchange-checkbox" id="okx">
                    <span class="exchange-name">OKX</span>
                    <select class="exchange-dropdown">
                        <option>C·∫∑p USDT</option>
                    </select>
                </div>
                <div class="exchange-item" id="huobi-item">
                    <input type="checkbox" class="exchange-checkbox" id="huobi">
                    <span class="exchange-name">Huobi</span>
                    <select class="exchange-dropdown">
                        <option>C·∫∑p USDT</option>
                    </select>
                </div>
                <div class="exchange-item" id="gate-item">
                    <input type="checkbox" class="exchange-checkbox" id="gate">
                    <span class="exchange-name">Gate</span>
                    <select class="exchange-dropdown">
                        <option>C·∫∑p USDT</option>
                    </select>
                </div>
                <div class="exchange-item" id="mexc-item">
                    <input type="checkbox" class="exchange-checkbox" id="mexc">
                    <span class="exchange-name">MEXC</span>
                    <select class="exchange-dropdown">
                        <option>C·∫∑p USDT</option>
                    </select>
                </div>
                <div class="exchange-item" id="bybit-item">
                    <input type="checkbox" class="exchange-checkbox" id="bybit">
                    <span class="exchange-name">Bybit</span>
                    <select class="exchange-dropdown">
                        <option>C·∫∑p USDT</option>
                    </select>
                </div>
            </div>

            <div class="exclusion-section">
                <div class="exclusion-item">
                    <input type="checkbox" class="exclusion-checkbox" id="excludeLeveraged" checked>
                    <span>Lo·∫°i tr·ª´ Token ƒê√≤n b·∫©y</span>
                </div>
                <div class="exclusion-item">
                    <input type="checkbox" class="exclusion-checkbox" id="excludeFutures" checked>
                    <span>Lo·∫°i tr·ª´ Futures</span>
                </div>
            </div>

            <div class="candle-section">
                <div class="candle-title">ƒêi·ªÅu Ki·ªán N·∫øn</div>
                
                <div class="condition-radio-group">
                    <div class="radio-item">
                        <input type="radio" class="radio-input" id="condition1" name="candleCondition" value="body" checked>
                        <div>
                            <label class="radio-label" for="condition1">ƒêi·ªÅu ki·ªán 1: Th√¢n n·∫øn < 15%</label>
                            <div class="radio-description">|Gi√° ƒë√≥ng - Gi√° m·ªü| / (Gi√° tr·∫ßn - Gi√° s√†n) < 15%</div>
                        </div>
                    </div>
                    <div class="radio-item">
                        <input type="radio" class="radio-input" id="condition2" name="candleCondition" value="priceChange">
                        <div>
                            <label class="radio-label" for="condition2">ƒêi·ªÅu ki·ªán 2: Thay ƒë·ªïi gi√° < 20%</label>
                            <div class="radio-description">|Gi√° ƒë√≥ng - Gi√° m·ªü| / Gi√° m·ªü < 20%</div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">Qu√©t (N) n·∫øn 3D g·∫ßn nh·∫•t</label>
                    <input type="number" class="input-field" id="candleCount" value="6" min="1" max="100">
                </div>
                
                <div class="input-group">
                    <label class="input-label">Gi√° tr·ªã ƒëi·ªÅu ki·ªán (%)</label>
                    <input type="number" class="input-field" id="conditionValue" value="15" min="1" max="100" step="0.1">
                </div>
            </div>

            <div class="volume-section">
                <div class="candle-title">ƒêi·ªÅu Ki·ªán Kh·ªëi L∆∞·ª£ng</div>
                <div class="input-group">
                    <label class="input-label">Kh·ªëi l∆∞·ª£ng > Trung b√¨nh (N) phi√™n</label>
                    <input type="number" class="input-field" id="volumePeriods" value="20" min="1" max="100">
                </div>
            </div>

            <button class="scan-button" id="scanButton">L·∫•y D·ªØ Li·ªáu</button>
        </div>

        <div class="results-area" id="resultsArea">
            <div class="loading hidden" id="loading">
                <h2>üîç ƒêang qu√©t th·ªã tr∆∞·ªùng...</h2>
                <p>Vui l√≤ng ch·ªù trong khi ch√∫ng t√¥i ph√¢n t√≠ch d·ªØ li·ªáu...</p>
                
                <!-- Progress Container -->
                <div class="progress-container" id="progressContainer">
                    <div class="progress-header">
                        <div class="progress-title">Ti·∫øn tr√¨nh qu√©t</div>
                        <div class="progress-status" id="progressStatus">Chu·∫©n b·ªã...</div>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        <div class="progress-text" id="progressText">0%</div>
                    </div>
                    
                    <div class="progress-details" id="progressDetails">
                        <!-- Progress items will be added here -->
                    </div>
                </div>
            </div>
            
            <table class="results-table hidden" id="resultsTable">
                <thead>
                    <tr>
                        <th>C·∫∑p</th>
                        <th>S√†n</th>
                        <th>Thay ƒë·ªïi 24h</th>
                        <th>Kh·ªëi l∆∞·ª£ng</th>
                        <th>ƒêi·ªÅu ki·ªán th·ªèa m√£n</th>
                    </tr>
                </thead>
                <tbody id="resultsBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Chart Modal -->
    <div class="chart-modal" id="chartModal">
        <div class="chart-container">
            <div class="chart-header">
                <div class="chart-title" id="chartTitle">Bi·ªÉu ƒë·ªì n·∫øn</div>
                <button class="close-chart" id="closeChart">‚úï</button>
            </div>
            
            <div class="chart-info" id="chartInfo">
                <span>O: 0.18998</span>
                <span>H: 0.21799</span>
                <span>L: 0.18742</span>
                <span>C: 0.19086</span>
                <span>+0.00093 (+0.49%)</span>
            </div>
            
            <div class="candlestick-chart" id="candlestickChart">
                <!-- Chart will be drawn here -->
            </div>
            
            <div class="volume-chart" id="volumeChart">
                <!-- Volume chart will be drawn here -->
            </div>
            
            <div class="candle-details" id="candleDetails">
                <!-- Th√¥ng tin chi ti·∫øt v·ªÅ c√°c n·∫øn 3D -->
            </div>
            
            <div class="chart-legend">
                <div class="legend-item">
                    <span class="legend-color legend-green"></span>
                    <span>N·∫øn tƒÉng (Gi√° ƒë√≥ng > Gi√° m·ªü)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color legend-red"></span>
                    <span>N·∫øn gi·∫£m (Gi√° ƒë√≥ng < Gi√° m·ªü)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color legend-highlight"></span>
                    <span>N·∫øn ƒë∆∞·ª£c ch·ªçn (Hi·ªán t·∫°i)</span>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        Crypto Scanner Pro - Phi√™n b·∫£n Portable | S·∫µn s√†ng qu√©t th·ªã tr∆∞·ªùng
    </div>

    <script>
        // Crypto Scanner Pro - Phi√™n b·∫£n Portable
        // Kh√¥ng c·∫ßn c√†i ƒë·∫∑t - ch·∫°y tr√™n m·ªçi tr√¨nh duy·ªát
        
        class CryptoScannerPortable {
            constructor() {
                this.initializeApp();
                this.setupEventListeners();
                this.updateStatusBar('S·∫µn s√†ng qu√©t th·ªã tr∆∞·ªùng');
                this.selectedRow = null;
            }

            initializeApp() {
                this.scanButton = document.getElementById('scanButton');
                this.filterPanel = document.getElementById('filterPanel');
                this.resultsArea = document.getElementById('resultsArea');
                this.loading = document.getElementById('loading');
                this.resultsTable = document.getElementById('resultsTable');
                this.resultsBody = document.getElementById('resultsBody');
                this.statusBar = document.querySelector('.status-bar');
                this.chartModal = document.getElementById('chartModal');
                this.closeChart = document.getElementById('closeChart');
                
                // Progress elements
                this.progressContainer = document.getElementById('progressContainer');
                this.progressStatus = document.getElementById('progressStatus');
                this.progressFill = document.getElementById('progressFill');
                this.progressText = document.getElementById('progressText');
                this.progressDetails = document.getElementById('progressDetails');
                
                // Progress tracking
                this.totalTasks = 0;
                this.completedTasks = 0;
                this.progressItems = new Map();
            }

            setupEventListeners() {
                // N√∫t qu√©t
                this.scanButton.addEventListener('click', () => this.startScan());

                // Checkbox s√†n giao d·ªãch
                document.querySelectorAll('.exchange-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => this.handleExchangeChange(e));
                });

                // Radio button ƒëi·ªÅu ki·ªán n·∫øn
                document.querySelectorAll('input[name="candleCondition"]').forEach(radio => {
                    radio.addEventListener('change', (e) => this.handleConditionChange(e));
                });

                // Input fields
                document.querySelectorAll('.input-field').forEach(input => {
                    input.addEventListener('input', () => this.updateStatusBar('C√†i ƒë·∫∑t ƒë√£ c·∫≠p nh·∫≠t'));
                });

                // Close chart modal
                this.closeChart.addEventListener('click', () => this.closeChartModal());
                
                // Close modal when clicking outside
                this.chartModal.addEventListener('click', (e) => {
                    if (e.target === this.chartModal) {
                        this.closeChartModal();
                    }
                });
            }

            handleExchangeChange(event) {
                const checkbox = event.target;
                const exchangeItem = checkbox.closest('.exchange-item');
                
                if (checkbox.checked) {
                    exchangeItem.classList.add('selected');
                    exchangeItem.style.background = '#4a4a4a';
                } else {
                    exchangeItem.classList.remove('selected');
                    exchangeItem.style.background = '#3a3a3a';
                }

                const exchangeNames = {
                    'binance': 'Binance',
                    'okx': 'OKX',
                    'huobi': 'Huobi',
                    'gate': 'Gate',
                    'mexc': 'MEXC',
                    'bybit': 'Bybit'
                };

                this.updateStatusBar(`S√†n ${exchangeNames[checkbox.id]} ${checkbox.checked ? 'ƒë√£ b·∫≠t' : 'ƒë√£ t·∫Øt'}`);
            }

            handleConditionChange(event) {
                const radio = event.target;
                const conditionValue = document.getElementById('conditionValue');
                
                if (radio.value === 'body') {
                    conditionValue.value = '15';
                    conditionValue.placeholder = '15';
                    this.updateStatusBar('ƒê√£ ch·ªçn ƒëi·ªÅu ki·ªán: Th√¢n n·∫øn < 15% (|Gi√° ƒë√≥ng - Gi√° m·ªü| / (Gi√° tr·∫ßn - Gi√° s√†n))');
                } else {
                    conditionValue.value = '20';
                    conditionValue.placeholder = '20';
                    this.updateStatusBar('ƒê√£ ch·ªçn ƒëi·ªÅu ki·ªán: Thay ƒë·ªïi gi√° < 20% (|Gi√° ƒë√≥ng - Gi√° m·ªü| / Gi√° m·ªü)');
                }
            }

            async startScan() {
                try {
                    // Log th·ªùi gian b·∫Øt ƒë·∫ßu scan
                    const startTime = new Date().toISOString();
                    console.log(`üöÄ B·∫Øt ƒë·∫ßu scan l√∫c: ${startTime}`);
                    
                    this.updateStatusBar('B·∫Øt ƒë·∫ßu qu√©t th·ªã tr∆∞·ªùng...');
                    this.showLoading();
                    
                    const filters = this.getFilterValues();
                    
                    if (filters.exchanges.length === 0) {
                        this.showError('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt s√†n giao d·ªãch!');
                        this.updateStatusBar('Ch∆∞a ch·ªçn s√†n giao d·ªãch');
                        return;
                    }
                    
                    this.updateStatusBar(`ƒêang k·∫øt n·ªëi v·ªõi ${filters.exchanges.length} s√†n giao d·ªãch...`);
                    
                    // Log th√¥ng tin v·ªÅ c√°c s√†n ƒë∆∞·ª£c ch·ªçn
                    console.log(`üìã C√°c s√†n ƒë∆∞·ª£c ch·ªçn:`, filters.exchanges);
                    console.log(`‚öôÔ∏è C·∫•u h√¨nh scan:`, {
                        candleCount: filters.candleCount,
                        selectedCondition: filters.selectedCondition,
                        conditionValue: filters.conditionValue,
                        volumePeriods: filters.volumePeriods,
                        excludeLeveraged: filters.excludeLeveraged,
                        excludeFutures: filters.excludeFutures
                    });
                    
                    // L·∫•y d·ªØ li·ªáu th·ª±c t·ª´ c√°c s√†n ƒë√£ ch·ªçn
                    const results = await this.fetchRealDataFromExchanges(filters);
                    
                    this.hideLoading();
                    this.showResults(results);
                    this.collapseFilterPanel();
                    
                    if (results.length > 0) {
                        this.updateStatusBar(`Qu√©t ho√†n th√†nh! T√¨m th·∫•y ${results.length} c·∫∑p th·ªèa m√£n ƒëi·ªÅu ki·ªán`);
                    } else {
                        this.updateStatusBar('Qu√©t ho√†n th√†nh! Kh√¥ng t√¨m th·∫•y c·∫∑p n√†o th·ªèa m√£n ƒëi·ªÅu ki·ªán');
                    }
                    
                } catch (error) {
                    console.error('L·ªói qu√©t:', error);
                    this.showError('Qu√©t th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i.');
                    this.updateStatusBar('Qu√©t th·∫•t b·∫°i');
                }
            }

            getFilterValues() {
                const selectedCondition = document.querySelector('input[name="candleCondition"]:checked').value;
                
                return {
                    exchanges: Array.from(document.querySelectorAll('.exchange-checkbox:checked')).map(cb => cb.id),
                    excludeLeveraged: document.getElementById('excludeLeveraged').checked,
                    excludeFutures: document.getElementById('excludeFutures').checked,
                    candleCount: document.getElementById('candleCount').value,
                    selectedCondition: selectedCondition,
                    conditionValue: document.getElementById('conditionValue').value,
                    volumePeriods: document.getElementById('volumePeriods').value
                };
            }

            async fetchRealDataFromExchanges(filters) {
                const exchanges = ['Binance', 'OKX', 'Huobi', 'Gate', 'MEXC', 'Bybit'];
                const results = [];
                let hasRealData = false;
                
                console.log('üîç B·∫Øt ƒë·∫ßu qu√©t v·ªõi ƒëi·ªÅu ki·ªán:', filters);
                
                // L·∫•y t·∫•t c·∫£ c·∫∑p USDT t·ª´ t·ª´ng s√†n
                for (const exchangeId of filters.exchanges) {
                    try {
                        this.updateStatusBar(`ƒêang l·∫•y danh s√°ch c·∫∑p t·ª´ ${exchanges.find(name => name.toLowerCase() === exchangeId)}...`);
                        console.log(`\nüì° ƒêang l·∫•y danh s√°ch c·∫∑p t·ª´ s√†n: ${exchangeId}`);
                        
                        // L·∫•y t·∫•t c·∫£ c·∫∑p USDT t·ª´ s√†n
                        const allPairs = await this.getAllUSDTPairs(exchangeId);
                        console.log(`  üìä T√¨m th·∫•y ${allPairs.length} c·∫∑p USDT tr√™n ${exchangeId}`);
                        
                        if (allPairs.length === 0) {
                            console.log(`  ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c·∫∑p USDT n√†o tr√™n ${exchangeId}`);
                            continue;
                        }
                        
                        // Kh·ªüi t·∫°o ti·∫øn tr√¨nh cho t·∫•t c·∫£ c·∫∑p
                        this.initializeProgress([exchangeId], allPairs);
                        
                        // Qu√©t t·ª´ng c·∫∑p
                        for (const pair of allPairs) {
                            const progressKey = `${exchangeId}-${pair}`;
                            
                            try {
                                // C·∫≠p nh·∫≠t tr·∫°ng th√°i: ƒêang x·ª≠ l√Ω
                                this.updateProgressItem(progressKey, 'processing');
                                console.log(`  üìä ƒêang x·ª≠ l√Ω c·∫∑p: ${pair}`);
                                
                                const exchangeData = await this.fetchExchangeData(exchangeId, pair, filters);
                                
                                if (exchangeData && exchangeData.candles.length > 0) {
                                    hasRealData = true;
                                    console.log(`  ‚úÖ Nh·∫≠n ƒë∆∞·ª£c ${exchangeData.candles.length} n·∫øn 3D t·ª´ ${exchangeId} cho ${pair}`);
                                    
                                    // Ki·ªÉm tra ƒëi·ªÅu ki·ªán v·ªõi d·ªØ li·ªáu th·ª±c
                                    console.log(`  üîç Ki·ªÉm tra ƒëi·ªÅu ki·ªán n·∫øn...`);
                                    const candleConditionMet = this.checkCandleCondition(exchangeData.candles, filters.selectedCondition, filters.conditionValue);
                                    
                                    console.log(`  üîç Ki·ªÉm tra ƒëi·ªÅu ki·ªán volume...`);
                                    const volumeConditionMet = this.checkVolumeCondition(exchangeData.volumes);
                                    
                                    console.log(`  üìã K·∫øt qu·∫£ ki·ªÉm tra: N·∫øn=${candleConditionMet}, Volume=${volumeConditionMet}`);
                                    
                                    if (candleConditionMet && volumeConditionMet) {
                                        const lastCandle = exchangeData.candles[exchangeData.candles.length - 1];
                                        const change24h = ((lastCandle.close - lastCandle.open) / lastCandle.open * 100).toFixed(3);
                                        
                                        console.log(`  üéØ C·∫∑p ${pair} th·ªèa m√£n c·∫£ hai ƒëi·ªÅu ki·ªán!`);
                                        
                                        results.push({
                                            pair: pair,
                                            exchange: exchanges.find(name => name.toLowerCase() === exchangeId),
                                            change24h: change24h,
                                            volume: exchangeData.volumes[exchangeData.volumes.length - 1],
                                            conditionMet: this.getConditionDescription(filters.selectedCondition),
                                            exchangeId: exchangeId,
                                            candleData: exchangeData.candles,
                                            volumeData: exchangeData.volumes
                                        });
                                        
                                        // C·∫≠p nh·∫≠t tr·∫°ng th√°i: Th√†nh c√¥ng
                                        this.updateProgressItem(progressKey, 'success');
                                    } else {
                                        console.log(`  ‚ùå C·∫∑p ${pair} kh√¥ng th·ªèa m√£n ƒëi·ªÅu ki·ªán`);
                                        // C·∫≠p nh·∫≠t tr·∫°ng th√°i: Th√†nh c√¥ng (nh∆∞ng kh√¥ng th·ªèa m√£n ƒëi·ªÅu ki·ªán)
                                        this.updateProgressItem(progressKey, 'success');
                                    }
                                } else {
                                    console.log(`  ‚ö†Ô∏è Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu n·∫øn t·ª´ ${exchangeId} cho ${pair}`);
                                    // C·∫≠p nh·∫≠t tr·∫°ng th√°i: L·ªói
                                    this.updateProgressItem(progressKey, 'error', 'Kh√¥ng c√≥ d·ªØ li·ªáu');
                                }
                                
                                // Ho√†n th√†nh task
                                this.completeTask();
                                
                                // Delay nh·ªè ƒë·ªÉ tr√°nh rate limiting
                                await this.delay(100);
                                
                            } catch (pairError) {
                                console.error(`  ‚ùå L·ªói l·∫•y d·ªØ li·ªáu c·∫∑p ${pair} t·ª´ ${exchangeId}:`, pairError);
                                // C·∫≠p nh·∫≠t tr·∫°ng th√°i: L·ªói
                                this.updateProgressItem(progressKey, 'error', 'L·ªói API');
                                this.completeTask();
                            }
                        }
                        
                    } catch (exchangeError) {
                        console.error(`‚ùå L·ªói l·∫•y d·ªØ li·ªáu t·ª´ s√†n ${exchangeId}:`, exchangeError);
                    }
                }
                
                console.log(`\nüìä T·ªïng k·∫øt: T√¨m th·∫•y ${results.length} c·∫∑p th·ªèa m√£n ƒëi·ªÅu ki·ªán`);
                
                // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu th·ª±c, s·ª≠ d·ª•ng d·ªØ li·ªáu m·∫´u
                if (!hasRealData) {
                    this.updateStatusBar('Kh√¥ng th·ªÉ k·∫øt n·ªëi API, s·ª≠ d·ª•ng d·ªØ li·ªáu m·∫´u...');
                    console.log('üîÑ Chuy·ªÉn sang s·ª≠ d·ª•ng d·ªØ li·ªáu m·∫´u...');
                    return this.generateMockResults(filters);
                }
                
                return results;
            }

            async fetchExchangeData(exchangeId, pair, filters) {
                try {
                    const symbol = this.convertPairToSymbol(pair, exchangeId);
                    const candleCount = parseInt(filters.candleCount) || 6;
                    const volumePeriods = parseInt(filters.volumePeriods) || 20;
                    
                    let candles = [];
                    let volumes = [];
                    
                    switch (exchangeId) {
                        case 'binance':
                            const binanceData = await this.fetchBinanceData(symbol, candleCount);
                            candles = binanceData.candles;
                            volumes = binanceData.volumes;
                            break;
                            
                        case 'okx':
                            const okxData = await this.fetchOKXData(symbol, candleCount);
                            candles = okxData.candles;
                            volumes = okxData.volumes;
                            break;
                            
                        case 'huobi':
                            const huobiData = await this.fetchHuobiData(symbol, candleCount);
                            candles = huobiData.candles;
                            volumes = huobiData.volumes;
                            break;
                            
                        case 'gate':
                            const gateData = await this.fetchGateData(symbol, candleCount);
                            candles = gateData.candles;
                            volumes = gateData.volumes;
                            break;
                            
                        case 'mexc':
                            const mexcData = await this.fetchMEXCData(symbol, candleCount);
                            candles = mexcData.candles;
                            volumes = mexcData.volumes;
                            break;
                            
                        case 'bybit':
                            const bybitData = await this.fetchBybitData(symbol, candleCount);
                            candles = bybitData.candles;
                            volumes = bybitData.volumes;
                            break;
                            
                        default:
                            console.error(`S√†n kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: ${exchangeId}`);
                            return null;
                    }
                    
                    // T·∫°o d·ªØ li·ªáu volume m·∫´u n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu th·ª±c
                    if (volumes.length === 0) {
                        volumes = this.generateVolumeDataForPair(volumePeriods);
                    }
                    
                    return { candles, volumes };
                    
                } catch (error) {
                    console.error(`L·ªói l·∫•y d·ªØ li·ªáu t·ª´ ${exchangeId}:`, error);
                    return null;
                }
            }

            // L·∫•y t·∫•t c·∫£ c·∫∑p USDT t·ª´ m·ªói s√†n
            async getAllUSDTPairs(exchangeId) {
                try {
                    switch (exchangeId) {
                        case 'binance':
                            return await this.getBinanceUSDTPairs();
                        case 'okx':
                            return await this.getOKXUSDTPairs();
                        case 'huobi':
                            return await this.getHuobiUSDTPairs();
                        case 'gate':
                            return await this.getGateUSDTPairs();
                        case 'mexc':
                            return await this.getMEXCUSDTPairs();
                        case 'bybit':
                            return await this.getBybitUSDTPairs();
                        default:
                            console.error(`S√†n kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: ${exchangeId}`);
                            return [];
                    }
                } catch (error) {
                    console.error(`L·ªói l·∫•y danh s√°ch c·∫∑p t·ª´ ${exchangeId}:`, error);
                    return [];
                }
            }

            // Binance - L·∫•y t·∫•t c·∫£ c·∫∑p USDT
            async getBinanceUSDTPairs() {
                const fallbackPairs = [
                    'BTC/USDT', 'ETH/USDT', 'ADA/USDT', 'DOT/USDT', 'LINK/USDT', 
                    'UNI/USDT', 'LTC/USDT', 'BCH/USDT', 'XRP/USDT', 'SOL/USDT',
                    'MATIC/USDT', 'AVAX/USDT', 'ATOM/USDT', 'NEAR/USDT', 'FTM/USDT'
                ];
                
                const data = await this.fetchWithFallback('https://api.binance.com/api/v3/exchangeInfo', { symbols: [] });
                
                if (data && data.symbols && data.symbols.length > 0) {
                    return data.symbols
                        .filter(symbol => symbol.quoteAsset === 'USDT' && symbol.status === 'TRADING')
                        .map(symbol => symbol.baseAsset + '/USDT');
                }
                
                console.log('S·ª≠ d·ª•ng danh s√°ch c·∫∑p m·∫´u cho Binance');
                return fallbackPairs;
            }

            // OKX - L·∫•y t·∫•t c·∫£ c·∫∑p USDT
            async getOKXUSDTPairs() {
                const fallbackPairs = [
                    'BTC/USDT', 'ETH/USDT', 'ADA/USDT', 'DOT/USDT', 'LINK/USDT', 
                    'UNI/USDT', 'LTC/USDT', 'BCH/USDT', 'XRP/USDT', 'SOL/USDT',
                    'MATIC/USDT', 'AVAX/USDT', 'ATOM/USDT', 'NEAR/USDT', 'FTM/USDT'
                ];
                
                const data = await this.fetchWithFallback('https://www.okx.com/api/v5/public/instruments?instType=SPOT', { data: [] });
                
                if (data && data.data && data.data.length > 0) {
                    return data.data
                        .filter(instrument => instrument.quoteCcy === 'USDT' && instrument.state === 'live')
                        .map(instrument => instrument.baseCcy + '/USDT');
                }
                
                console.log('S·ª≠ d·ª•ng danh s√°ch c·∫∑p m·∫´u cho OKX');
                return fallbackPairs;
            }

            // Huobi - L·∫•y t·∫•t c·∫£ c·∫∑p USDT
            async getHuobiUSDTPairs() {
                const fallbackPairs = [
                    'BTC/USDT', 'ETH/USDT', 'ADA/USDT', 'DOT/USDT', 'LINK/USDT', 
                    'UNI/USDT', 'LTC/USDT', 'BCH/USDT', 'XRP/USDT', 'SOL/USDT',
                    'MATIC/USDT', 'AVAX/USDT', 'ATOM/USDT', 'NEAR/USDT', 'FTM/USDT'
                ];
                
                const data = await this.fetchWithFallback('https://api.huobi.pro/v1/common/symbols', { data: [] });
                
                if (data && data.data && data.data.length > 0) {
                    return data.data
                        .filter(symbol => symbol.quoteCurrency === 'usdt' && symbol.state === 'online')
                        .map(symbol => symbol.baseCurrency.toUpperCase() + '/USDT');
                }
                
                console.log('S·ª≠ d·ª•ng danh s√°ch c·∫∑p m·∫´u cho Huobi');
                return fallbackPairs;
            }

            // Gate - L·∫•y t·∫•t c·∫£ c·∫∑p USDT
            async getGateUSDTPairs() {
                const fallbackPairs = [
                    'BTC/USDT', 'ETH/USDT', 'ADA/USDT', 'DOT/USDT', 'LINK/USDT', 
                    'UNI/USDT', 'LTC/USDT', 'BCH/USDT', 'XRP/USDT', 'SOL/USDT',
                    'MATIC/USDT', 'AVAX/USDT', 'ATOM/USDT', 'NEAR/USDT', 'FTM/USDT'
                ];
                
                const data = await this.fetchWithFallback('https://api.gateio.ws/api/v4/spot/currency_pairs', []);
                
                if (data && data.length > 0) {
                    return data
                        .filter(pair => pair.quote === 'USDT' && pair.trade_status === 'tradable')
                        .map(pair => pair.base + '/USDT');
                }
                
                console.log('S·ª≠ d·ª•ng danh s√°ch c·∫∑p m·∫´u cho Gate');
                return fallbackPairs;
            }

            // MEXC - L·∫•y t·∫•t c·∫£ c·∫∑p USDT
            async getMEXCUSDTPairs() {
                const fallbackPairs = [
                    'BTC/USDT', 'ETH/USDT', 'ADA/USDT', 'DOT/USDT', 'LINK/USDT', 
                    'UNI/USDT', 'LTC/USDT', 'BCH/USDT', 'XRP/USDT', 'SOL/USDT',
                    'MATIC/USDT', 'AVAX/USDT', 'ATOM/USDT', 'NEAR/USDT', 'FTM/USDT'
                ];
                
                const data = await this.fetchWithFallback('https://www.mexc.com/api/platform/spot/market/info', { data: [] });
                
                if (data && data.data && data.data.length > 0) {
                    return data.data
                        .filter(market => market.quoteCurrency === 'USDT' && market.status === 1)
                        .map(market => market.baseCurrency + '/USDT');
                }
                
                console.log('S·ª≠ d·ª•ng danh s√°ch c·∫∑p m·∫´u cho MEXC');
                return fallbackPairs;
            }

            // Bybit - L·∫•y t·∫•t c·∫£ c·∫∑p USDT
            async getBybitUSDTPairs() {
                const fallbackPairs = [
                    'BTC/USDT', 'ETH/USDT', 'ADA/USDT', 'DOT/USDT', 'LINK/USDT', 
                    'UNI/USDT', 'LTC/USDT', 'BCH/USDT', 'XRP/USDT', 'SOL/USDT',
                    'MATIC/USDT', 'AVAX/USDT', 'ATOM/USDT', 'NEAR/USDT', 'FTM/USDT'
                ];
                
                const data = await this.fetchWithFallback('https://api.bybit.com/v5/market/instruments-info?category=spot', { result: { list: [] } });
                
                if (data && data.result && data.result.list && data.result.list.length > 0) {
                    return data.result.list
                        .filter(instrument => instrument.quoteCoin === 'USDT' && instrument.status === 'Trading')
                        .map(instrument => instrument.baseCoin + '/USDT');
                }
                
                console.log('S·ª≠ d·ª•ng danh s√°ch c·∫∑p m·∫´u cho Bybit');
                return fallbackPairs;
            }

            convertPairToSymbol(pair, exchangeId) {
                // Chuy·ªÉn ƒë·ªïi BTC/USDT th√†nh format ph√π h·ª£p v·ªõi t·ª´ng s√†n
                const [base, quote] = pair.split('/');
                
                switch (exchangeId) {
                    case 'binance':
                    case 'okx':
                    case 'bybit':
                        return `${base}${quote}`; // BTCUSDT
                    case 'huobi':
                        return `${base.toLowerCase()}${quote.toLowerCase()}`; // btcusdt
                    case 'gate':
                        return `${base}_${quote}`; // BTC_USDT
                    case 'mexc':
                        return `${base}_${quote}`; // BTC_USDT
                    default:
                        return `${base}${quote}`;
                }
            }

            generateMockResults(filters) {
                const exchanges = ['Binance', 'OKX', 'Huobi', 'Gate', 'MEXC', 'Bybit'];
                
                // Ch·ªâ t·∫°o k·∫øt qu·∫£ cho c√°c s√†n ƒë√£ ch·ªçn
                const selectedExchanges = filters.exchanges;
                const results = [];
                
                // T·∫°o k·∫øt qu·∫£ m·∫´u cho m·ªói s√†n ƒë√£ ch·ªçn
                selectedExchanges.forEach(exchangeId => {
                    const exchangeName = exchanges.find(name => name.toLowerCase() === exchangeId) || exchangeId;
                    
                    // T·∫°o m·ªôt s·ªë c·∫∑p m·∫´u ph·ªï bi·∫øn
                    const samplePairs = ['BTC/USDT', 'ETH/USDT', 'ADA/USDT', 'DOT/USDT', 'LINK/USDT', 'UNI/USDT', 'LTC/USDT', 'BCH/USDT', 'XRP/USDT'];
                    
                    // T·∫°o 2-4 k·∫øt qu·∫£ cho m·ªói s√†n
                    const numResults = Math.floor(Math.random() * 3) + 2;
                    
                    for (let i = 0; i < numResults; i++) {
                        const randomPair = samplePairs[Math.floor(Math.random() * samplePairs.length)];
                        
                        // T·∫°o d·ªØ li·ªáu n·∫øn th·ª±c t·∫ø ƒë·ªÉ ki·ªÉm tra ƒëi·ªÅu ki·ªán
                        const candleData = this.generateCandleDataForPair(randomPair, filters.candleCount);
                        const volumeData = this.generateVolumeDataForPair(filters.volumePeriods);
                        
                        // Ki·ªÉm tra ƒëi·ªÅu ki·ªán n·∫øn
                        const candleConditionMet = this.checkCandleCondition(candleData, filters.selectedCondition, filters.conditionValue);
                        
                        // Ki·ªÉm tra ƒëi·ªÅu ki·ªán kh·ªëi l∆∞·ª£ng
                        const volumeConditionMet = this.checkVolumeCondition(volumeData);
                        
                        // Ch·ªâ th√™m v√†o k·∫øt qu·∫£ n·∫øu th·ªèa m√£n c·∫£ hai ƒëi·ªÅu ki·ªán
                        if (candleConditionMet && volumeConditionMet) {
                            const lastCandle = candleData[candleData.length - 1];
                            const change24h = ((lastCandle.close - lastCandle.open) / lastCandle.open * 100).toFixed(3);
                            
                            results.push({
                                pair: randomPair,
                                exchange: exchangeName,
                                change24h: change24h,
                                volume: volumeData[volumeData.length - 1],
                                conditionMet: this.getConditionDescription(filters.selectedCondition),
                                exchangeId: exchangeId,
                                candleData: candleData,
                                volumeData: volumeData
                            });
                        }
                    }
                });
                
                return results;
            }

            generateCandleDataForPair(pair, candleCount) {
                const candles = [];
                
                // T·∫°o gi√° c∆° b·∫£n d·ª±a tr√™n c·∫∑p giao d·ªãch
                let basePrice;
                if (pair.includes('BTC')) {
                    basePrice = 40000 + Math.random() * 10000; // BTC: 40k-50k
                } else if (pair.includes('ETH')) {
                    basePrice = 2000 + Math.random() * 500; // ETH: 2k-2.5k
                } else if (pair.includes('ADA')) {
                    basePrice = 0.4 + Math.random() * 0.2; // ADA: 0.4-0.6
                } else if (pair.includes('DOT')) {
                    basePrice = 5 + Math.random() * 2; // DOT: 5-7
                } else if (pair.includes('LINK')) {
                    basePrice = 12 + Math.random() * 3; // LINK: 12-15
                } else if (pair.includes('UNI')) {
                    basePrice = 6 + Math.random() * 2; // UNI: 6-8
                } else if (pair.includes('LTC')) {
                    basePrice = 60 + Math.random() * 20; // LTC: 60-80
                } else if (pair.includes('BCH')) {
                    basePrice = 200 + Math.random() * 50; // BCH: 200-250
                } else if (pair.includes('XRP')) {
                    basePrice = 0.5 + Math.random() * 0.2; // XRP: 0.5-0.7
                } else {
                    basePrice = 1 + Math.random() * 10; // M·∫∑c ƒë·ªãnh: 1-11
                }
                
                for (let i = 0; i < candleCount; i++) {
                    // Simulate price movement over time
                    const trend = Math.sin(i * 0.5) * 0.01; // Gentle wave pattern
                    const volatility = (Math.random() - 0.5) * 0.02;
                    
                    const open = basePrice + trend + volatility;
                    const close = open + (Math.random() - 0.5) * 0.015;
                    const high = Math.max(open, close) + Math.random() * 0.008;
                    const low = Math.min(open, close) - Math.random() * 0.008;
                    
                    candles.push({ open, high, low, close });
                    basePrice = close; // Next candle opens at previous close
                }
                
                return candles;
            }

            generateVolumeDataForPair(volumePeriods) {
                const volumes = [];
                let baseVolume = 1000000 + Math.random() * 5000000; // 1M-6M
                
                for (let i = 0; i < volumePeriods; i++) {
                    // Simulate volume variation
                    const variation = 0.3 + Math.random() * 1.4; // 0.3x to 1.7x
                    const volume = Math.floor(baseVolume * variation);
                    volumes.push(volume);
                    
                    // Slight trend in volume
                    baseVolume = baseVolume * (0.9 + Math.random() * 0.2);
                }
                
                return volumes;
            }

            // API Functions for each exchange - S·ª≠a l·∫°i ƒë·ªÉ ch√≠nh x√°c h∆°n
            async fetchBinanceData(symbol, candleCount) {
                try {
                    // Th·ª≠ s·ª≠ d·ª•ng interval 3d tr·ª±c ti·∫øp tr∆∞·ªõc
                    let data = await this.fetchWithRateLimit(
                        `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=3d&limit=${candleCount}`,
                        []
                    );
                    
                    this.logFetchDetails('Binance', symbol, data, 'Th·ª≠ 3D tr·ª±c ti·∫øp');
                    
                    // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu 3d, th·ª≠ s·ª≠ d·ª•ng 1d v√† g·ªôp
                    if (!data || data.length === 0) {
                        console.log(`üìä Binance ${symbol}: Kh√¥ng c√≥ interval 3d, s·ª≠ d·ª•ng 1d v√† g·ªôp`);
                        data = await this.fetchWithRateLimit(
                            `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1d&limit=${candleCount * 3}`,
                            []
                        );
                        
                        this.logFetchDetails('Binance', symbol, data, 'Fallback 1D ƒë·ªÉ g·ªôp');
                        
                        if (data && data.length > 0) {
                            // G·ªôp 3 n·∫øn 1d th√†nh 1 n·∫øn 3d theo c√°ch ch√≠nh x√°c h∆°n
                            const candles = [];
                            // D·ªØ li·ªáu t·ª´ API ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp theo th·ªùi gian tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                            for (let i = 0; i < data.length; i += 3) {
                                if (i + 2 < data.length) {
                                    const day1 = data[i];        // Ng√†y 1
                                    const day2 = data[i + 1];    // Ng√†y 2  
                                    const day3 = data[i + 2];    // Ng√†y 3
                                    
                                    // T√≠nh to√°n n·∫øn 3D t·ª´ 3 n·∫øn 1D - c·∫£i thi·ªán logic
                                    const open = parseFloat(day1[1]);  // Gi√° m·ªü c·ªßa ng√†y ƒë·∫ßu ti√™n
                                    const high = Math.max(parseFloat(day1[2]), parseFloat(day2[2]), parseFloat(day3[2])); // Gi√° cao nh·∫•t trong 3 ng√†y
                                    const low = Math.min(parseFloat(day1[3]), parseFloat(day2[3]), parseFloat(day3[3]));   // Gi√° th·∫•p nh·∫•t trong 3 ng√†y
                                    const close = parseFloat(day3[4]); // Gi√° ƒë√≥ng c·ªßa ng√†y cu·ªëi c√πng
                                    const volume = parseFloat(day1[5]) + parseFloat(day2[5]) + parseFloat(day3[5]); // T·ªïng kh·ªëi l∆∞·ª£ng 3 ng√†y
                                    
                                    candles.push({ open, high, low, close, volume });
                                }
                            }
                            
                            console.log(`üìä Binance ${symbol}: G·ªôp ${data.length} n·∫øn 1D th√†nh ${candles.length} n·∫øn 3D`);
                            this.checkDataConsistency('Binance', symbol, candles);
                            const volumes = candles.map(c => c.volume);
                            return { candles, volumes };
                        }
                    } else {
                        // S·ª≠ d·ª•ng d·ªØ li·ªáu 3D tr·ª±c ti·∫øp
                        const candles = [];
                        data.forEach(candle => {
                            const open = parseFloat(candle[1]);
                            const high = parseFloat(candle[2]);
                            const low = parseFloat(candle[3]);
                            const close = parseFloat(candle[4]);
                            const volume = parseFloat(candle[5]);
                            
                            candles.push({ open, high, low, close, volume });
                        });
                        
                        console.log(`üìä Binance ${symbol}: S·ª≠ d·ª•ng ${candles.length} n·∫øn 3D tr·ª±c ti·∫øp`);
                        this.checkDataConsistency('Binance', symbol, candles);
                        const volumes = candles.map(c => c.volume);
                        return { candles, volumes };
                    }
                    
                    return { candles: [], volumes: [] };
                } catch (error) {
                    console.error('L·ªói Binance API:', error);
                    return { candles: [], volumes: [] };
                }
            }

            async fetchOKXData(symbol, candleCount) {
                try {
                    // Th·ª≠ s·ª≠ d·ª•ng interval 3D tr·ª±c ti·∫øp tr∆∞·ªõc
                    let data = await this.fetchWithRateLimit(
                        `https://www.okx.com/api/v5/market/candles?instId=${symbol}-USDT&bar=3D&limit=${candleCount}`,
                        { data: [] }
                    );
                    
                    // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu 3D, th·ª≠ s·ª≠ d·ª•ng 1D v√† g·ªôp
                    if (!data.data || data.data.length === 0) {
                        console.log(`üìä OKX ${symbol}: Kh√¥ng c√≥ interval 3D, s·ª≠ d·ª•ng 1D v√† g·ªôp`);
                        data = await this.fetchWithRateLimit(
                            `https://www.okx.com/api/v5/market/candles?instId=${symbol}-USDT&bar=1D&limit=${candleCount * 3}`,
                            { data: [] }
                        );
                        
                        if (data.data && data.data.length > 0) {
                            const candles = [];
                            // OKX API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                            // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                            const reversedData = data.data.reverse();
                            
                            // G·ªôp 3 n·∫øn 1D th√†nh 1 n·∫øn 3D
                            for (let i = 0; i < reversedData.length; i += 3) {
                                if (i + 2 < reversedData.length) {
                                    const day1 = reversedData[i];        // Ng√†y 1
                                    const day2 = reversedData[i + 1];    // Ng√†y 2  
                                    const day3 = reversedData[i + 2];    // Ng√†y 3
                                    
                                    // T√≠nh to√°n n·∫øn 3D t·ª´ 3 n·∫øn 1D
                                    const open = parseFloat(day1[1]);  // Gi√° m·ªü c·ªßa ng√†y ƒë·∫ßu ti√™n
                                    const high = Math.max(parseFloat(day1[2]), parseFloat(day2[2]), parseFloat(day3[2])); // Gi√° cao nh·∫•t trong 3 ng√†y
                                    const low = Math.min(parseFloat(day1[3]), parseFloat(day2[3]), parseFloat(day3[3]));   // Gi√° th·∫•p nh·∫•t trong 3 ng√†y
                                    const close = parseFloat(day3[4]); // Gi√° ƒë√≥ng c·ªßa ng√†y cu·ªëi c√πng
                                    const volume = parseFloat(day1[5]) + parseFloat(day2[5]) + parseFloat(day3[5]); // T·ªïng kh·ªëi l∆∞·ª£ng 3 ng√†y
                                    
                                    candles.push({ open, high, low, close, volume });
                                }
                            }
                            
                            console.log(`üìä OKX ${symbol}: G·ªôp ${reversedData.length} n·∫øn 1D th√†nh ${candles.length} n·∫øn 3D`);
                            const volumes = candles.map(c => c.volume);
                            return { candles, volumes };
                        }
                    } else {
                        // S·ª≠ d·ª•ng d·ªØ li·ªáu 3D tr·ª±c ti·∫øp
                        const candles = [];
                        // OKX API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                        // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                        const reversedData = data.data.reverse();
                        
                        reversedData.forEach(candle => {
                            const open = parseFloat(candle[1]);
                            const high = parseFloat(candle[2]);
                            const low = parseFloat(candle[3]);
                            const close = parseFloat(candle[4]);
                            const volume = parseFloat(candle[5]);
                            
                            candles.push({ open, high, low, close, volume });
                        });
                        
                        console.log(`üìä OKX ${symbol}: S·ª≠ d·ª•ng ${candles.length} n·∫øn 3D tr·ª±c ti·∫øp`);
                        const volumes = candles.map(c => c.volume);
                        return { candles, volumes };
                    }
                    
                    return { candles: [], volumes: [] };
                } catch (error) {
                    console.error('L·ªói OKX API:', error);
                    return { candles: [], volumes: [] };
                }
            }

            async fetchHuobiData(symbol, candleCount) {
                try {
                    // Th·ª≠ s·ª≠ d·ª•ng interval 3d tr·ª±c ti·∫øp tr∆∞·ªõc
                    let data = await this.fetchWithRateLimit(
                        `https://api.huobi.pro/market/history/kline?symbol=${symbol}&period=3d&size=${candleCount}`,
                        { data: [] }
                    );
                    
                    // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu 3d, th·ª≠ s·ª≠ d·ª•ng 1d v√† g·ªôp
                    if (!data.data || data.data.length === 0) {
                        console.log(`üìä Huobi ${symbol}: Kh√¥ng c√≥ interval 3d, s·ª≠ d·ª•ng 1d v√† g·ªôp`);
                        data = await this.fetchWithRateLimit(
                            `https://api.huobi.pro/market/history/kline?symbol=${symbol}&period=1d&size=${candleCount * 3}`,
                            { data: [] }
                        );
                        
                        if (data.data && data.data.length > 0) {
                            const candles = [];
                            // Huobi API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                            // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                            const reversedData = data.data.reverse();
                            
                            // G·ªôp 3 n·∫øn 1D th√†nh 1 n·∫øn 3D
                            for (let i = 0; i < reversedData.length; i += 3) {
                                if (i + 2 < reversedData.length) {
                                    const day1 = reversedData[i];        // Ng√†y 1
                                    const day2 = reversedData[i + 1];    // Ng√†y 2  
                                    const day3 = reversedData[i + 2];    // Ng√†y 3
                                    
                                    // T√≠nh to√°n n·∫øn 3D t·ª´ 3 n·∫øn 1D
                                    const open = parseFloat(day1.open);  // Gi√° m·ªü c·ªßa ng√†y ƒë·∫ßu ti√™n
                                    const high = Math.max(parseFloat(day1.high), parseFloat(day2.high), parseFloat(day3.high)); // Gi√° cao nh·∫•t trong 3 ng√†y
                                    const low = Math.min(parseFloat(day1.low), parseFloat(day2.low), parseFloat(day3.low));   // Gi√° th·∫•p nh·∫•t trong 3 ng√†y
                                    const close = parseFloat(day3.close); // Gi√° ƒë√≥ng c·ªßa ng√†y cu·ªëi c√πng
                                    const volume = parseFloat(day1.vol) + parseFloat(day2.vol) + parseFloat(day3.vol); // T·ªïng kh·ªëi l∆∞·ª£ng 3 ng√†y
                                    
                                    candles.push({ open, high, low, close, volume });
                                }
                            }
                            
                            console.log(`üìä Huobi ${symbol}: G·ªôp ${reversedData.length} n·∫øn 1D th√†nh ${candles.length} n·∫øn 3D`);
                            const volumes = candles.map(c => c.volume);
                            return { candles, volumes };
                        }
                    } else {
                        // S·ª≠ d·ª•ng d·ªØ li·ªáu 3D tr·ª±c ti·∫øp
                        const candles = [];
                        // Huobi API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                        // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                        const reversedData = data.data.reverse();
                        
                        reversedData.forEach(candle => {
                            const open = parseFloat(candle.open);
                            const high = parseFloat(candle.high);
                            const low = parseFloat(candle.low);
                            const close = parseFloat(candle.close);
                            const volume = parseFloat(candle.vol);
                            
                            candles.push({ open, high, low, close, volume });
                        });
                        
                        console.log(`üìä Huobi ${symbol}: S·ª≠ d·ª•ng ${candles.length} n·∫øn 3D tr·ª±c ti·∫øp`);
                        const volumes = candles.map(c => c.volume);
                        return { candles, volumes };
                    }
                    
                    return { candles: [], volumes: [] };
                } catch (error) {
                    console.error('L·ªói Huobi API:', error);
                    return { candles: [], volumes: [] };
                }
            }

            async fetchGateData(symbol, candleCount) {
                try {
                    // Th·ª≠ s·ª≠ d·ª•ng interval 3d tr·ª±c ti·∫øp tr∆∞·ªõc
                    let data = await this.fetchWithRateLimit(
                        `https://api.gateio.ws/api/v4/spot/candlesticks?currency_pair=${symbol}&interval=3d&limit=${candleCount}`,
                        []
                    );
                    
                    // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu 3d, th·ª≠ s·ª≠ d·ª•ng 1d v√† g·ªôp
                    if (!data || data.length === 0) {
                        console.log(`üìä Gate ${symbol}: Kh√¥ng c√≥ interval 3d, s·ª≠ d·ª•ng 1d v√† g·ªôp`);
                        data = await this.fetchWithRateLimit(
                            `https://api.gateio.ws/api/v4/spot/candlesticks?currency_pair=${symbol}&interval=1d&limit=${candleCount * 3}`,
                            []
                        );
                        
                        if (data && data.length > 0) {
                            const candles = [];
                            // Gate API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                            // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                            const reversedData = data.reverse();
                            
                            // G·ªôp 3 n·∫øn 1D th√†nh 1 n·∫øn 3D
                            for (let i = 0; i < reversedData.length; i += 3) {
                                if (i + 2 < reversedData.length) {
                                    const day1 = reversedData[i];        // Ng√†y 1
                                    const day2 = reversedData[i + 1];    // Ng√†y 2  
                                    const day3 = reversedData[i + 2];    // Ng√†y 3
                                    
                                    // T√≠nh to√°n n·∫øn 3D t·ª´ 3 n·∫øn 1D
                                    const open = parseFloat(day1[2]);  // Gi√° m·ªü c·ªßa ng√†y ƒë·∫ßu ti√™n
                                    const high = Math.max(parseFloat(day1[3]), parseFloat(day2[3]), parseFloat(day3[3])); // Gi√° cao nh·∫•t trong 3 ng√†y
                                    const low = Math.min(parseFloat(day1[4]), parseFloat(day2[4]), parseFloat(day3[4]));   // Gi√° th·∫•p nh·∫•t trong 3 ng√†y
                                    const close = parseFloat(day3[5]); // Gi√° ƒë√≥ng c·ªßa ng√†y cu·ªëi c√πng
                                    const volume = parseFloat(day1[6]) + parseFloat(day2[6]) + parseFloat(day3[6]); // T·ªïng kh·ªëi l∆∞·ª£ng 3 ng√†y
                                    
                                    candles.push({ open, high, low, close, volume });
                                }
                            }
                            
                            console.log(`üìä Gate ${symbol}: G·ªôp ${reversedData.length} n·∫øn 1D th√†nh ${candles.length} n·∫øn 3D`);
                            const volumes = candles.map(c => c.volume);
                            return { candles, volumes };
                        }
                    } else {
                        // S·ª≠ d·ª•ng d·ªØ li·ªáu 3D tr·ª±c ti·∫øp
                        const candles = [];
                        // Gate API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                        // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                        const reversedData = data.reverse();
                        
                        reversedData.forEach(candle => {
                            const open = parseFloat(candle[2]);
                            const high = parseFloat(candle[3]);
                            const low = parseFloat(candle[4]);
                            const close = parseFloat(candle[5]);
                            const volume = parseFloat(candle[6]);
                            
                            candles.push({ open, high, low, close, volume });
                        });
                        
                        console.log(`üìä Gate ${symbol}: S·ª≠ d·ª•ng ${candles.length} n·∫øn 3D tr·ª±c ti·∫øp`);
                        const volumes = candles.map(c => c.volume);
                        return { candles, volumes };
                    }
                    
                    return { candles: [], volumes: [] };
                } catch (error) {
                    console.error('L·ªói Gate API:', error);
                    return { candles: [], volumes: [] };
                }
            }

            async fetchMEXCData(symbol, candleCount) {
                try {
                    // Th·ª≠ s·ª≠ d·ª•ng interval 3d tr·ª±c ti·∫øp tr∆∞·ªõc
                    let data = await this.fetchWithRateLimit(
                        `https://www.mexc.com/api/platform/spot/market/kline?symbol=${symbol}&interval=3d&limit=${candleCount}`,
                        { data: [] }
                    );
                    
                    // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu 3d, th·ª≠ s·ª≠ d·ª•ng 1d v√† g·ªôp
                    if (!data.data || data.data.length === 0) {
                        console.log(`üìä MEXC ${symbol}: Kh√¥ng c√≥ interval 3d, s·ª≠ d·ª•ng 1d v√† g·ªôp`);
                        data = await this.fetchWithRateLimit(
                            `https://www.mexc.com/api/platform/spot/market/kline?symbol=${symbol}&interval=1d&limit=${candleCount * 3}`,
                            { data: [] }
                        );
                        
                        if (data.data && data.data.length > 0) {
                            const candles = [];
                            // MEXC API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                            // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                            const reversedData = data.data.reverse();
                            
                            // G·ªôp 3 n·∫øn 1D th√†nh 1 n·∫øn 3D
                            for (let i = 0; i < reversedData.length; i += 3) {
                                if (i + 2 < reversedData.length) {
                                    const day1 = reversedData[i];        // Ng√†y 1
                                    const day2 = reversedData[i + 1];    // Ng√†y 2  
                                    const day3 = reversedData[i + 2];    // Ng√†y 3
                                    
                                    // T√≠nh to√°n n·∫øn 3D t·ª´ 3 n·∫øn 1D
                                    const open = parseFloat(day1.open);  // Gi√° m·ªü c·ªßa ng√†y ƒë·∫ßu ti√™n
                                    const high = Math.max(parseFloat(day1.high), parseFloat(day2.high), parseFloat(day3.high)); // Gi√° cao nh·∫•t trong 3 ng√†y
                                    const low = Math.min(parseFloat(day1.low), parseFloat(day2.low), parseFloat(day3.low));   // Gi√° th·∫•p nh·∫•t trong 3 ng√†y
                                    const close = parseFloat(day3.close); // Gi√° ƒë√≥ng c·ªßa ng√†y cu·ªëi c√πng
                                    const volume = parseFloat(day1.volume) + parseFloat(day2.volume) + parseFloat(day3.volume); // T·ªïng kh·ªëi l∆∞·ª£ng 3 ng√†y
                                    
                                    candles.push({ open, high, low, close, volume });
                                }
                            }
                            
                            console.log(`üìä MEXC ${symbol}: G·ªôp ${reversedData.length} n·∫øn 1D th√†nh ${candles.length} n·∫øn 3D`);
                            const volumes = candles.map(c => c.volume);
                            return { candles, volumes };
                        }
                    } else {
                        // S·ª≠ d·ª•ng d·ªØ li·ªáu 3D tr·ª±c ti·∫øp
                        const candles = [];
                        // MEXC API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                        // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                        const reversedData = data.data.reverse();
                        
                        reversedData.forEach(candle => {
                            const open = parseFloat(candle.open);
                            const high = parseFloat(candle.high);
                            const low = parseFloat(candle.low);
                            const close = parseFloat(candle.close);
                            const volume = parseFloat(candle.volume);
                            
                            candles.push({ open, high, low, close, volume });
                        });
                        
                        console.log(`üìä MEXC ${symbol}: S·ª≠ d·ª•ng ${candles.length} n·∫øn 3D tr·ª±c ti·∫øp`);
                        const volumes = candles.map(c => c.volume);
                        return { candles, volumes };
                    }
                    
                    return { candles: [], volumes: [] };
                } catch (error) {
                    console.error('L·ªói MEXC API:', error);
                    return { candles: [], volumes: [] };
                }
            }

            async fetchBybitData(symbol, candleCount) {
                try {
                    // Th·ª≠ s·ª≠ d·ª•ng interval 3d tr·ª±c ti·∫øp tr∆∞·ªõc (interval=3 cho Bybit)
                    let data = await this.fetchWithRateLimit(
                        `https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=3&limit=${candleCount}`,
                        { result: { list: [] } }
                    );
                    
                    // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu 3d, th·ª≠ s·ª≠ d·ª•ng 1d v√† g·ªôp
                    if (!data.result || !data.result.list || data.result.list.length === 0) {
                        console.log(`üìä Bybit ${symbol}: Kh√¥ng c√≥ interval 3d, s·ª≠ d·ª•ng 1d v√† g·ªôp`);
                        data = await this.fetchWithRateLimit(
                            `https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=1&limit=${candleCount * 3}`,
                            { result: { list: [] } }
                        );
                        
                        if (data.result && data.result.list && data.result.list.length > 0) {
                            const candles = [];
                            // Bybit API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                            // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                            const reversedData = data.result.list.reverse();
                            
                            // G·ªôp 3 n·∫øn 1D th√†nh 1 n·∫øn 3D
                            for (let i = 0; i < reversedData.length; i += 3) {
                                if (i + 2 < reversedData.length) {
                                    const day1 = reversedData[i];        // Ng√†y 1
                                    const day2 = reversedData[i + 1];    // Ng√†y 2  
                                    const day3 = reversedData[i + 2];    // Ng√†y 3
                                    
                                    // T√≠nh to√°n n·∫øn 3D t·ª´ 3 n·∫øn 1D
                                    const open = parseFloat(day1[1]);  // Gi√° m·ªü c·ªßa ng√†y ƒë·∫ßu ti√™n
                                    const high = Math.max(parseFloat(day1[2]), parseFloat(day2[2]), parseFloat(day3[2])); // Gi√° cao nh·∫•t trong 3 ng√†y
                                    const low = Math.min(parseFloat(day1[3]), parseFloat(day2[3]), parseFloat(day3[3]));   // Gi√° th·∫•p nh·∫•t trong 3 ng√†y
                                    const close = parseFloat(day3[4]); // Gi√° ƒë√≥ng c·ªßa ng√†y cu·ªëi c√πng
                                    const volume = parseFloat(day1[5]) + parseFloat(day2[5]) + parseFloat(day3[5]); // T·ªïng kh·ªëi l∆∞·ª£ng 3 ng√†y
                                    
                                    candles.push({ open, high, low, close, volume });
                                }
                            }
                            
                            console.log(`üìä Bybit ${symbol}: G·ªôp ${reversedData.length} n·∫øn 1D th√†nh ${candles.length} n·∫øn 3D`);
                            const volumes = candles.map(c => c.volume);
                            return { candles, volumes };
                        }
                    } else {
                        // S·ª≠ d·ª•ng d·ªØ li·ªáu 3D tr·ª±c ti·∫øp
                        const candles = [];
                        // Bybit API tr·∫£ v·ªÅ d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian gi·∫£m d·∫ßn (m·ªõi nh·∫•t -> c≈© nh·∫•t)
                        // C·∫ßn ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ c√≥ th·ª© t·ª± tƒÉng d·∫ßn (c≈© nh·∫•t -> m·ªõi nh·∫•t)
                        const reversedData = data.result.list.reverse();
                        
                        reversedData.forEach(candle => {
                            const open = parseFloat(candle[1]);
                            const high = parseFloat(candle[2]);
                            const low = parseFloat(candle[3]);
                            const close = parseFloat(candle[4]);
                            const volume = parseFloat(candle[5]);
                            
                            candles.push({ open, high, low, close, volume });
                        });
                        
                        console.log(`üìä Bybit ${symbol}: S·ª≠ d·ª•ng ${candles.length} n·∫øn 3D tr·ª±c ti·∫øp`);
                        const volumes = candles.map(c => c.volume);
                        return { candles, volumes };
                    }
                    
                    return { candles: [], volumes: [] };
                } catch (error) {
                    console.error('L·ªói Bybit API:', error);
                    return { candles: [], volumes: [] };
                }
            }

            checkCandleCondition(candleData, selectedCondition, conditionValue) {
                // Ki·ªÉm tra t·ª´ng n·∫øn trong 6 n·∫øn 3D g·∫ßn nh·∫•t
                for (let i = 0; i < candleData.length; i++) {
                    const candle = candleData[i];
                    const open = candle.open;
                    const close = candle.close;
                    
                    let conditionMet = false;
                    
                    if (selectedCondition === 'body') {
                        // ƒêi·ªÅu ki·ªán 1: Th√¢n n·∫øn < 15%
                        // Th√¢n n·∫øn = |Gi√° ƒë√≥ng - Gi√° m·ªü| / (Gi√° tr·∫ßn - Gi√° s√†n) * 100
                        const bodyPercent = Math.abs(close - open) / (candle.high - candle.low) * 100;
                        conditionMet = bodyPercent < parseFloat(conditionValue);
                        
                        console.log(`N·∫øn ${i + 1}: Open=${open.toFixed(5)}, Close=${close.toFixed(5)}, High=${candle.high.toFixed(5)}, Low=${candle.low.toFixed(5)}, Body%=${bodyPercent.toFixed(2)}%, ƒêi·ªÅu ki·ªán < ${conditionValue}%: ${conditionMet}`);
                    } else {
                        // ƒêi·ªÅu ki·ªán 2: Tr·ªã tuy·ªát ƒë·ªëi c·ªßa hi·ªáu gi√° ƒë√≥ng/m·ªü so v·ªõi gi√° m·ªü < 20%
                        // ƒê√¢y ch√≠nh l√† th√¢n n·∫øn, n√™n logic gi·ªëng ƒëi·ªÅu ki·ªán 1
                        const changePercent = Math.abs((close - open) / open * 100);
                        conditionMet = changePercent < parseFloat(conditionValue);
                        
                        console.log(`N·∫øn ${i + 1}: Open=${open.toFixed(5)}, Close=${close.toFixed(5)}, Thay ƒë·ªïi%=${changePercent.toFixed(2)}%, ƒêi·ªÅu ki·ªán < ${conditionValue}%: ${conditionMet}`);
                    }
                    
                    // N·∫øu b·∫•t k·ª≥ n·∫øn n√†o th·ªèa m√£n ƒëi·ªÅu ki·ªán, tr·∫£ v·ªÅ true
                    if (conditionMet) {
                        console.log(`‚úÖ N·∫øn ${i + 1} th·ªèa m√£n ƒëi·ªÅu ki·ªán!`);
                        return true;
                    }
                }
                
                console.log('‚ùå Kh√¥ng c√≥ n·∫øn n√†o th·ªèa m√£n ƒëi·ªÅu ki·ªán');
                return false;
            }

            checkVolumeCondition(volumeData) {
                if (volumeData.length < 2) return false;
                
                // L·∫•y kh·ªëi l∆∞·ª£ng hi·ªán t·∫°i (n·∫øn cu·ªëi c√πng)
                const currentVolume = volumeData[volumeData.length - 1];
                
                // T√≠nh trung b√¨nh kh·ªëi l∆∞·ª£ng c·ªßa c√°c phi√™n tr∆∞·ªõc ƒë√≥ (kh√¥ng t√≠nh phi√™n hi·ªán t·∫°i)
                const previousVolumes = volumeData.slice(0, -1);
                const averageVolume = previousVolumes.reduce((sum, vol) => sum + vol, 0) / previousVolumes.length;
                
                // Ki·ªÉm tra: Kh·ªëi l∆∞·ª£ng hi·ªán t·∫°i > Trung b√¨nh c√°c phi√™n tr∆∞·ªõc
                const conditionMet = currentVolume > averageVolume;
                
                console.log(`üìä Volume: Hi·ªán t·∫°i=${currentVolume.toLocaleString()}, Trung b√¨nh=${averageVolume.toLocaleString()}, ƒêi·ªÅu ki·ªán >: ${conditionMet}`);
                
                return conditionMet;
            }

            getConditionDescription(condition) {
                if (condition === 'body') {
                    return 'Th√¢n n·∫øn < 15% + Kh·ªëi l∆∞·ª£ng';
                } else {
                    return 'Thay ƒë·ªïi gi√° < 20% + Kh·ªëi l∆∞·ª£ng';
                }
            }

            showLoading() {
                this.loading.classList.remove('hidden');
                this.resultsTable.classList.add('hidden');
            }

            hideLoading() {
                this.loading.classList.add('hidden');
            }

            showResults(results) {
                this.resultsTable.classList.remove('hidden');
                this.populateResultsTable(results);
            }

            populateResultsTable(results) {
                this.resultsBody.innerHTML = '';
                
                results.forEach((result, index) => {
                    const row = document.createElement('tr');
                    row.dataset.index = index;
                    row.innerHTML = `
                        <td><strong>${result.pair}</strong></td>
                        <td>${result.exchange}</td>
                        <td style="color: ${result.change24h > 0 ? '#4CAF50' : '#f44336'}">${result.change24h}%</td>
                        <td>${result.volume.toLocaleString()}</td>
                        <td><span style="color: #ffd700;">${result.conditionMet}</span></td>
                    `;
                    
                    // Add click event to show chart
                    row.addEventListener('click', () => this.showChart(result, index));
                    
                    this.resultsBody.appendChild(row);
                });
            }

            showChart(result, index) {
                // Remove previous selection
                if (this.selectedRow) {
                    this.selectedRow.classList.remove('selected');
                }
                
                // Select current row
                const currentRow = this.resultsBody.querySelector(`tr[data-index="${index}"]`);
                if (currentRow) {
                    currentRow.classList.add('selected');
                    this.selectedRow = currentRow;
                }

                // Store current result data for candle clicks
                this.currentResult = result;

                // Update chart title and info
                document.getElementById('chartTitle').textContent = `${result.pair} ¬∑ 3D ¬∑ ${result.exchange}`;
                
                // S·ª≠ d·ª•ng d·ªØ li·ªáu th·ª±c t·∫ø t·ª´ k·∫øt qu·∫£ qu√©t
                const candleData = result.candleData;
                const volumeData = result.volumeData;
                
                // L·∫•y n·∫øn cu·ªëi c√πng (hi·ªán t·∫°i) ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin OHLC
                const currentCandle = candleData[candleData.length - 1];
                
                // Update chart info v·ªõi d·ªØ li·ªáu th·ª±c t·∫ø
                this.updateChartInfo(currentCandle, result.change24h, candleData.length - 1);
                
                // Draw charts v·ªõi d·ªØ li·ªáu th·ª±c t·∫ø v√† highlight n·∫øn cu·ªëi c√πng (hi·ªán t·∫°i)
                this.drawCandlestickChart(candleData, candleData.length - 1);
                this.drawVolumeChart(volumeData, volumeData.length - 1);
                
                // Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt v·ªÅ c√°c n·∫øn 3D
                this.displayCandleDetails(candleData, candleData.length - 1);
                
                // Show modal
                this.chartModal.classList.add('show');
            }

            drawGridLines(svg, chartWidth, chartHeight, margin, minPrice, maxPrice) {
                const priceToY = (price) => {
                    return chartHeight - margin - ((price - minPrice) / (maxPrice - minPrice)) * (chartHeight - 2 * margin);
                };
                
                // Horizontal grid lines (price levels)
                const priceLevels = 5;
                for (let i = 0; i <= priceLevels; i++) {
                    const price = minPrice + (maxPrice - minPrice) * (i / priceLevels);
                    const y = priceToY(price);
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', margin);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', chartWidth - margin);
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', '#e0e0e0');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,5');
                    svg.appendChild(line);
                }
                
                // Vertical grid lines (time levels)
                const timeLevels = 4;
                for (let i = 0; i <= timeLevels; i++) {
                    const x = margin + (chartWidth - 2 * margin) * (i / timeLevels);
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', margin);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', chartHeight - margin);
                    line.setAttribute('stroke', '#e0e0e0');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,5');
                    svg.appendChild(line);
                }
            }

            drawPriceLabels(svg, chartWidth, chartHeight, margin, minPrice, maxPrice) {
                const priceToY = (price) => {
                    return chartHeight - margin - ((price - minPrice) / (maxPrice - minPrice)) * (chartHeight - 2 * margin);
                };
                
                const priceLevels = 5;
                for (let i = 0; i <= priceLevels; i++) {
                    const price = minPrice + (maxPrice - minPrice) * (i / priceLevels);
                    const y = priceToY(price);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', margin - 10);
                    text.setAttribute('y', y + 4);
                    text.setAttribute('text-anchor', 'end');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('fill', '#666');
                    text.textContent = price.toFixed(5);
                    svg.appendChild(text);
                }
            }

            drawTimeLabels(svg, chartWidth, chartHeight, margin, candleCount, startX, candleWidth, spacing) {
                const timeLabels = ['3D tr∆∞·ªõc', '2D tr∆∞·ªõc', '1D tr∆∞·ªõc', 'Hi·ªán t·∫°i'];
                const labelPositions = [0, Math.floor(candleCount / 3), Math.floor(2 * candleCount / 3), candleCount - 1];
                
                labelPositions.forEach((pos, index) => {
                    if (pos < candleCount) {
                        const x = startX + pos * (candleWidth + spacing) + candleWidth / 2;
                        const y = chartHeight - margin + 20;
                        
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', x);
                        text.setAttribute('y', y);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '12');
                        text.setAttribute('fill', '#666');
                        text.textContent = timeLabels[index];
                        svg.appendChild(text);
                    }
                });
            }

            drawCandlestickChart(candleData, highlightIndex = -1) {
                const chart = document.getElementById('candlestickChart');
                chart.innerHTML = '';
                
                // Create SVG for multiple candlesticks
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.setAttribute('viewBox', '0 0 800 300');
                
                // Calculate chart dimensions
                const chartWidth = 800;
                const chartHeight = 300;
                const margin = 50;
                const candleWidth = 30;
                const spacing = 20;
                const candleCount = candleData.length;
                const availableWidth = chartWidth - 2 * margin;
                const totalCandleWidth = candleCount * candleWidth + (candleCount - 1) * spacing;
                const startX = margin + (availableWidth - totalCandleWidth) / 2;
                
                // Find price range for scaling
                let minPrice = Math.min(...candleData.map(c => c.low));
                let maxPrice = Math.max(...candleData.map(c => c.high));
                const priceRange = maxPrice - minPrice;
                const padding = priceRange * 0.1;
                minPrice -= padding;
                maxPrice += padding;
                
                // Price scale function
                const priceToY = (price) => {
                    return chartHeight - margin - ((price - minPrice) / (maxPrice - minPrice)) * (chartHeight - 2 * margin);
                };
                
                // Draw grid lines
                this.drawGridLines(svg, chartWidth, chartHeight, margin, minPrice, maxPrice);
                
                // Draw price labels
                this.drawPriceLabels(svg, chartWidth, chartHeight, margin, minPrice, maxPrice);
                
                // Draw time labels
                this.drawTimeLabels(svg, chartWidth, chartHeight, margin, candleCount, startX, candleWidth, spacing);
                
                // Draw candlesticks
                candleData.forEach((candle, index) => {
                    const x = startX + index * (candleWidth + spacing);
                    const isGreen = candle.close > candle.open;
                    const color = isGreen ? '#4CAF50' : '#f44336';
                    
                    // Highlight n·∫øn ƒë∆∞·ª£c ch·ªçn
                    const isHighlighted = index === highlightIndex;
                    const highlightColor = isHighlighted ? '#FFD700' : color; // M√†u v√†ng cho n·∫øn ƒë∆∞·ª£c highlight
                    const highlightWidth = isHighlighted ? candleWidth + 4 : candleWidth;
                    const highlightX = isHighlighted ? x - 2 : x;
                    
                    // Create clickable group for each candle
                    const candleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    candleGroup.setAttribute('cursor', 'pointer');
                    candleGroup.setAttribute('data-index', index);
                    
                    // Add click event to the group
                    candleGroup.addEventListener('click', () => {
                        this.onCandleClick(index, candleData);
                    });
                    
                    // Draw wick (line from high to low)
                    const wickX = x + candleWidth / 2;
                    const wickY1 = priceToY(candle.high);
                    const wickY2 = priceToY(candle.low);
                    
                    const wick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    wick.setAttribute('x1', wickX);
                    wick.setAttribute('y1', wickY1);
                    wick.setAttribute('x2', wickX);
                    wick.setAttribute('y2', wickY2);
                    wick.setAttribute('stroke', highlightColor);
                    wick.setAttribute('stroke-width', isHighlighted ? '4' : '2');
                    candleGroup.appendChild(wick);
                    
                    // Draw body
                    const bodyY = priceToY(Math.max(candle.open, candle.close));
                    const bodyHeight = Math.abs(priceToY(candle.open) - priceToY(candle.close));
                    
                    const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    body.setAttribute('x', highlightX);
                    body.setAttribute('y', bodyY);
                    body.setAttribute('width', highlightWidth);
                    body.setAttribute('height', Math.max(bodyHeight, 2));
                    body.setAttribute('fill', highlightColor);
                    body.setAttribute('stroke', highlightColor);
                    body.setAttribute('stroke-width', isHighlighted ? '3' : '1');
                    candleGroup.appendChild(body);
                    
                    // Th√™m vi·ªÅn highlight cho n·∫øn ƒë∆∞·ª£c ch·ªçn
                    if (isHighlighted) {
                        const highlightBorder = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        highlightBorder.setAttribute('x', highlightX - 3);
                        highlightBorder.setAttribute('y', bodyY - 3);
                        highlightBorder.setAttribute('width', highlightWidth + 6);
                        highlightBorder.setAttribute('height', Math.max(bodyHeight, 2) + 6);
                        highlightBorder.setAttribute('fill', 'none');
                        highlightBorder.setAttribute('stroke', '#FFD700');
                        highlightBorder.setAttribute('stroke-width', '2');
                        highlightBorder.setAttribute('stroke-dasharray', '5,5');
                        svg.appendChild(highlightBorder);
                    }
                    
                    // Add hover effect
                    candleGroup.addEventListener('mouseenter', () => {
                        if (!isHighlighted) {
                            body.setAttribute('stroke-width', '3');
                            wick.setAttribute('stroke-width', '3');
                        }
                    });
                    
                    candleGroup.addEventListener('mouseleave', () => {
                        if (!isHighlighted) {
                            body.setAttribute('stroke-width', '1');
                            wick.setAttribute('stroke-width', '2');
                        }
                    });
                    
                    svg.appendChild(candleGroup);
                });
                
                chart.appendChild(svg);
            }

            drawVolumeChart(volumeData, highlightIndex = -1) {
                const chart = document.getElementById('volumeChart');
                chart.innerHTML = '';
                
                // Create SVG for volume chart
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.setAttribute('viewBox', '0 0 800 150');
                
                // Calculate chart dimensions
                const chartWidth = 800;
                const chartHeight = 150;
                const margin = 50;
                const barWidth = 30;
                const spacing = 20;
                const candleCount = volumeData.length;
                const availableWidth = chartWidth - 2 * margin;
                const totalBarWidth = candleCount * barWidth + (candleCount - 1) * spacing;
                const startX = margin + (availableWidth - totalBarWidth) / 2;
                
                // Find volume range for scaling
                const maxVolume = Math.max(...volumeData);
                const volumeToHeight = (volume) => {
                    return (volume / maxVolume) * (chartHeight - 2 * margin);
                };
                
                // Draw volume bars
                volumeData.forEach((volume, index) => {
                    const x = startX + index * (barWidth + spacing);
                    const height = volumeToHeight(volume);
                    const y = chartHeight - margin - height;
                    
                    // Highlight bar ƒë∆∞·ª£c ch·ªçn
                    const isHighlighted = index === highlightIndex;
                    const intensity = volume / maxVolume;
                    const baseColor = `rgba(76, 175, 80, ${0.3 + intensity * 0.7})`;
                    const highlightColor = isHighlighted ? '#FFD700' : baseColor;
                    const highlightWidth = isHighlighted ? barWidth + 4 : barWidth;
                    const highlightX = isHighlighted ? x - 2 : x;
                    
                    const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    bar.setAttribute('x', highlightX);
                    bar.setAttribute('y', y);
                    bar.setAttribute('width', highlightWidth);
                    bar.setAttribute('height', height);
                    bar.setAttribute('fill', highlightColor);
                    bar.setAttribute('stroke', isHighlighted ? '#FFD700' : '#4CAF50');
                    bar.setAttribute('stroke-width', isHighlighted ? '3' : '1');
                    svg.appendChild(bar);
                    
                    // Th√™m vi·ªÅn highlight cho bar ƒë∆∞·ª£c ch·ªçn
                    if (isHighlighted) {
                        const highlightBorder = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        highlightBorder.setAttribute('x', highlightX - 3);
                        highlightBorder.setAttribute('y', y - 3);
                        highlightBorder.setAttribute('width', highlightWidth + 6);
                        highlightBorder.setAttribute('height', height + 6);
                        highlightBorder.setAttribute('fill', 'none');
                        highlightBorder.setAttribute('stroke', '#FFD700');
                        highlightBorder.setAttribute('stroke-width', '2');
                        highlightBorder.setAttribute('stroke-dasharray', '5,5');
                        svg.appendChild(highlightBorder);
                    }
                    
                    // Add volume label
                    if (height > 20) { // Only show label if bar is tall enough
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', x + barWidth / 2);
                        text.setAttribute('y', y - 5);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '10');
                        text.setAttribute('fill', isHighlighted ? '#FFD700' : '#666');
                        text.textContent = (volume / 1000).toFixed(0) + 'K';
                        svg.appendChild(text);
                    }
                });
                
                // Add volume title
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', chartWidth / 2);
                title.setAttribute('y', 20);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('font-size', '14');
                title.setAttribute('font-weight', 'bold');
                title.setAttribute('fill', '#333');
                title.textContent = 'Kh·ªëi l∆∞·ª£ng giao d·ªãch';
                svg.appendChild(title);
                
                chart.appendChild(svg);
            }

            closeChartModal() {
                this.chartModal.classList.remove('show');
                
                // Remove row selection
                if (this.selectedRow) {
                    this.selectedRow.classList.remove('selected');
                    this.selectedRow = null;
                }
            }

            collapseFilterPanel() {
                this.filterPanel.style.width = '300px';
                this.filterPanel.style.transition = 'width 0.5s ease';
            }

            showError(message) {
                this.loading.innerHTML = `
                    <h2 style="color: #f44336;">‚ùå ƒê√£ x·∫£y ra l·ªói</h2>
                    <p>${message}</p>
                `;
            }

            updateStatusBar(message) {
                this.statusBar.textContent = `Crypto Scanner Pro - Phi√™n b·∫£n Portable | ${message}`;
            }

            // Progress Management Methods
            initializeProgress(exchanges, pairs) {
                this.totalTasks = exchanges.length * pairs.length;
                this.completedTasks = 0;
                this.progressItems.clear();
                this.progressDetails.innerHTML = '';
                
                // Create progress items for each exchange and pair
                exchanges.forEach(exchangeId => {
                    pairs.forEach(pair => {
                        const key = `${exchangeId}-${pair}`;
                        this.progressItems.set(key, {
                            exchange: exchangeId,
                            pair: pair,
                            status: 'pending'
                        });
                        
                        this.addProgressItem(key, exchangeId, pair);
                    });
                });
                
                this.updateProgress();
            }
            
            addProgressItem(key, exchangeId, pair) {
                const item = document.createElement('div');
                item.className = 'progress-item';
                item.id = `progress-${key}`;
                
                const exchangeNames = {
                    'binance': 'Binance',
                    'okx': 'OKX',
                    'huobi': 'Huobi',
                    'gate': 'Gate',
                    'mexc': 'MEXC',
                    'bybit': 'Bybit'
                };
                
                item.innerHTML = `
                    <div class="progress-item-name">${exchangeNames[exchangeId]} - ${pair}</div>
                    <div class="progress-item-status status-pending" id="status-${key}">Ch·ªù x·ª≠ l√Ω</div>
                `;
                
                this.progressDetails.appendChild(item);
            }
            
            updateProgressItem(key, status, message = '') {
                const item = this.progressItems.get(key);
                if (item) {
                    item.status = status;
                    
                    const statusElement = document.getElementById(`status-${key}`);
                    if (statusElement) {
                        statusElement.className = `progress-item-status status-${status}`;
                        
                        switch (status) {
                            case 'pending':
                                statusElement.textContent = 'Ch·ªù x·ª≠ l√Ω';
                                break;
                            case 'processing':
                                statusElement.textContent = 'ƒêang x·ª≠ l√Ω...';
                                break;
                            case 'success':
                                statusElement.textContent = 'Th√†nh c√¥ng';
                                break;
                            case 'error':
                                statusElement.textContent = message || 'L·ªói';
                                break;
                        }
                    }
                }
            }
            
            updateProgress() {
                const percentage = this.totalTasks > 0 ? Math.round((this.completedTasks / this.totalTasks) * 100) : 0;
                
                this.progressFill.style.width = `${percentage}%`;
                this.progressText.textContent = `${percentage}%`;
                
                if (percentage === 100) {
                    this.progressStatus.textContent = 'Ho√†n th√†nh!';
                } else {
                    this.progressStatus.textContent = `${this.completedTasks}/${this.totalTasks} ho√†n th√†nh`;
                }
            }
            
            completeTask() {
                this.completedTasks++;
                this.updateProgress();
            }

            displayCandleDetails(candleData, highlightIndex) {
                const candleDetails = document.getElementById('candleDetails');
                
                let html = '<h4>Chi ti·∫øt c√°c n·∫øn 3D</h4>';
                html += '<table class="candle-table">';
                html += '<thead><tr>';
                html += '<th>N·∫øn</th>';
                html += '<th>Th·ªùi gian</th>';
                html += '<th>Gi√° m·ªü</th>';
                html += '<th>Gi√° cao</th>';
                html += '<th>Gi√° th·∫•p</th>';
                html += '<th>Gi√° ƒë√≥ng</th>';
                html += '<th>Th√¢n n·∫øn (%)</th>';
                html += '<th>Thay ƒë·ªïi (%)</th>';
                html += '<th>Kh·ªëi l∆∞·ª£ng</th>';
                html += '</tr></thead><tbody>';
                
                const timeLabels = ['3D tr∆∞·ªõc', '2D tr∆∞·ªõc', '1D tr∆∞·ªõc', 'Hi·ªán t·∫°i'];
                
                candleData.forEach((candle, index) => {
                    const isHighlighted = index === highlightIndex;
                    const rowClass = isHighlighted ? 'highlighted' : '';
                    const timeLabel = timeLabels[index] || `N·∫øn ${index + 1}`;
                    
                    // C·∫≠p nh·∫≠t c√¥ng th·ª©c th√¢n n·∫øn theo ƒëi·ªÅu ki·ªán m·ªõi
                    const selectedCondition = document.querySelector('input[name="candleCondition"]:checked').value;
                    let bodyPercent;
                    if (selectedCondition === 'body') {
                        // Th√¢n n·∫øn = |Gi√° ƒë√≥ng - Gi√° m·ªü| / (Gi√° tr·∫ßn - Gi√° s√†n) * 100
                        bodyPercent = Math.abs(candle.close - candle.open) / (candle.high - candle.low) * 100;
                    } else {
                        // Th√¢n n·∫øn = |Gi√° ƒë√≥ng - Gi√° m·ªü| / Gi√° m·ªü * 100
                        bodyPercent = Math.abs(candle.close - candle.open) / candle.open * 100;
                    }
                    
                    const changePercent = ((candle.close - candle.open) / candle.open * 100);
                    const changeColor = changePercent > 0 ? '#4CAF50' : '#f44336';
                    const changeSign = changePercent > 0 ? '+' : '';
                    
                    html += `<tr class="${rowClass}" data-index="${index}" style="cursor: pointer;">`;
                    html += `<td>${index + 1}</td>`;
                    html += `<td>${timeLabel}</td>`;
                    html += `<td>${candle.open.toFixed(5)}</td>`;
                    html += `<td>${candle.high.toFixed(5)}</td>`;
                    html += `<td>${candle.low.toFixed(5)}</td>`;
                    html += `<td>${candle.close.toFixed(5)}</td>`;
                    html += `<td>${bodyPercent.toFixed(2)}%</td>`;
                    html += `<td style="color: ${changeColor}">${changeSign}${changePercent.toFixed(2)}%</td>`;
                    html += `<td>${candle.volume ? candle.volume.toLocaleString() : 'N/A'}</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                candleDetails.innerHTML = html;
                
                // Add click events to table rows
                const rows = candleDetails.querySelectorAll('tbody tr');
                rows.forEach((row, index) => {
                    row.addEventListener('click', () => {
                        this.onCandleClick(index, candleData);
                    });
                    
                    row.addEventListener('mouseenter', () => {
                        if (index !== highlightIndex) {
                            row.style.backgroundColor = '#4a4a4a';
                        }
                    });
                    
                    row.addEventListener('mouseleave', () => {
                        if (index !== highlightIndex) {
                            row.style.backgroundColor = '';
                        }
                    });
                });
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // Th√™m delay gi·ªØa c√°c API calls ƒë·ªÉ tr√°nh rate limiting
            async fetchWithRateLimit(url, fallbackData = null, delayMs = 100) {
                // Th√™m delay tr∆∞·ªõc khi g·ªçi API
                await this.delay(delayMs);
                return await this.fetchWithFallback(url, fallbackData);
            }

            // Ph∆∞∆°ng th·ª©c ƒë·ªÉ log chi ti·∫øt v·ªÅ vi·ªác fetch data
            logFetchDetails(exchange, symbol, data, method) {
                const timestamp = new Date().toISOString();
                console.log(`üïê [${timestamp}] ${exchange} ${symbol}: ${method}`);
                if (data && Array.isArray(data)) {
                    console.log(`   üìä S·ªë l∆∞·ª£ng candles: ${data.length}`);
                    if (data.length > 0) {
                        console.log(`   üìà Candle ƒë·∫ßu ti√™n:`, data[0]);
                        console.log(`   üìâ Candle cu·ªëi c√πng:`, data[data.length - 1]);
                    }
                } else if (data && data.data && Array.isArray(data.data)) {
                    console.log(`   üìä S·ªë l∆∞·ª£ng candles: ${data.data.length}`);
                    if (data.data.length > 0) {
                        console.log(`   üìà Candle ƒë·∫ßu ti√™n:`, data.data[0]);
                        console.log(`   üìâ Candle cu·ªëi c√πng:`, data.data[data.data.length - 1]);
                    }
                } else if (data && data.result && data.result.list && Array.isArray(data.result.list)) {
                    console.log(`   üìä S·ªë l∆∞·ª£ng candles: ${data.result.list.length}`);
                    if (data.result.list.length > 0) {
                        console.log(`   üìà Candle ƒë·∫ßu ti√™n:`, data.result.list[0]);
                        console.log(`   üìâ Candle cu·ªëi c√πng:`, data.result.list[data.result.list.length - 1]);
                    }
                } else {
                    console.log(`   ‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu ho·∫∑c format kh√¥ng ƒë√∫ng`);
                }
            }

            // Ph∆∞∆°ng th·ª©c ƒë·ªÉ ki·ªÉm tra t√≠nh nh·∫•t qu√°n c·ªßa d·ªØ li·ªáu
            checkDataConsistency(exchange, symbol, candles) {
                if (!candles || candles.length === 0) {
                    console.warn(`‚ö†Ô∏è ${exchange} ${symbol}: Kh√¥ng c√≥ d·ªØ li·ªáu candles`);
                    return false;
                }

                // Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa d·ªØ li·ªáu
                for (let i = 0; i < candles.length; i++) {
                    const candle = candles[i];
                    if (!candle.open || !candle.high || !candle.low || !candle.close || !candle.volume) {
                        console.error(`‚ùå ${exchange} ${symbol}: Candle ${i} c√≥ d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá:`, candle);
                        return false;
                    }
                    
                    // Ki·ªÉm tra logic gi√°
                    if (candle.high < candle.low || candle.high < candle.open || candle.high < candle.close ||
                        candle.low > candle.open || candle.low > candle.close) {
                        console.error(`‚ùå ${exchange} ${symbol}: Candle ${i} c√≥ gi√° kh√¥ng h·ª£p l·ªá:`, candle);
                        return false;
                    }
                }

                console.log(`‚úÖ ${exchange} ${symbol}: D·ªØ li·ªáu h·ª£p l·ªá (${candles.length} candles)`);
                return true;
            }

            // Helper method ƒë·ªÉ g·ªçi API v·ªõi fallback
            async fetchWithFallback(url, fallbackData = null) {
                try {
                    // Th·ª≠ g·ªçi API tr·ª±c ti·∫øp tr∆∞·ªõc
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`‚úÖ API call th√†nh c√¥ng: ${url}`);
                        return data;
                    } else {
                        console.warn(`‚ö†Ô∏è API call th·∫•t b·∫°i v·ªõi status ${response.status}: ${url}`);
                        this.updateStatusBar(`API call th·∫•t b·∫°i (${response.status}). S·ª≠ d·ª•ng d·ªØ li·ªáu m·∫´u.`, 'warning');
                    }
                } catch (error) {
                    console.error(`‚ùå L·ªói fetch t·ª´ ${url}:`, error);
                    this.updateStatusBar(`L·ªói k·∫øt n·ªëi API. S·ª≠ d·ª•ng d·ªØ li·ªáu m·∫´u. (${url})`, 'error');
                }
                
                // N·∫øu kh√¥ng th√†nh c√¥ng, tr·∫£ v·ªÅ fallback data
                console.log(`üîÑ S·ª≠ d·ª•ng fallback data cho: ${url}`);
                return fallbackData;
            }

            onCandleClick(candleIndex, candleData) {
                // Update chart info for the clicked candle
                const clickedCandle = candleData[candleIndex];
                const changePercent = ((clickedCandle.close - clickedCandle.open) / clickedCandle.open * 100);
                const change24h = changePercent.toFixed(3);
                
                this.updateChartInfo(clickedCandle, change24h, candleIndex);
                
                // Redraw charts with new highlight
                this.drawCandlestickChart(candleData, candleIndex);
                this.drawVolumeChart(this.currentResult.volumeData, candleIndex);
                
                // Update candle details table
                this.displayCandleDetails(candleData, candleIndex);
            }

            updateChartInfo(candle, change24h, candleIndex) {
                const change = parseFloat(change24h);
                const changeColor = change > 0 ? '#4CAF50' : '#f44336';
                const changeSign = change > 0 ? '+' : '';
                
                // T√≠nh to√°n th√¥ng tin chi ti·∫øt cho n·∫øn ƒë∆∞·ª£c ch·ªçn
                const selectedCondition = document.querySelector('input[name="candleCondition"]:checked').value;
                let bodyPercent;
                if (selectedCondition === 'body') {
                    // Th√¢n n·∫øn = |Gi√° ƒë√≥ng - Gi√° m·ªü| / (Gi√° tr·∫ßn - Gi√° s√†n) * 100
                    bodyPercent = Math.abs(candle.close - candle.open) / (candle.high - candle.low) * 100;
                } else {
                    // Th√¢n n·∫øn = |Gi√° ƒë√≥ng - Gi√° m·ªü| / Gi√° m·ªü * 100
                    bodyPercent = Math.abs(candle.close - candle.open) / candle.open * 100;
                }
                
                const conditionValue = document.getElementById('conditionValue').value;
                const conditionText = selectedCondition === 'body' ? `Th√¢n n·∫øn < ${conditionValue}%` : `Thay ƒë·ªïi gi√° < ${conditionValue}%`;
                
                // Ki·ªÉm tra xem n·∫øn c√≥ th·ªèa m√£n ƒëi·ªÅu ki·ªán kh√¥ng
                const conditionMet = selectedCondition === 'body' 
                    ? bodyPercent < parseFloat(conditionValue)
                    : Math.abs((candle.close - candle.open) / candle.open * 100) < parseFloat(conditionValue);
                
                const conditionStatus = conditionMet ? '‚úÖ Th·ªèa m√£n' : '‚ùå Kh√¥ng th·ªèa m√£n';
                const conditionColor = conditionMet ? '#4CAF50' : '#f44336';
                
                document.getElementById('chartInfo').innerHTML = `
                    <span>O: ${candle.open.toFixed(5)}</span>
                    <span>H: ${candle.high.toFixed(5)}</span>
                    <span>L: ${candle.low.toFixed(5)}</span>
                    <span>C: ${candle.close.toFixed(5)}</span>
                    <span style="color: ${changeColor}">${changeSign}${(candle.close - candle.open).toFixed(5)} (${changeSign}${change24h}%)</span>
                    <span style="color: #ffd700">Th√¢n: ${bodyPercent.toFixed(2)}%</span>
                    <span style="color: #00bcd4">ƒêi·ªÅu ki·ªán: ${conditionText}</span>
                    <span style="color: ${conditionColor}">${conditionStatus}</span>
                `;
            }
        }

        // Kh·ªüi t·∫°o ·ª©ng d·ª•ng khi trang t·∫£i xong
        document.addEventListener('DOMContentLoaded', () => {
            new CryptoScannerPortable();
        });
    </script>
</body>
</html>